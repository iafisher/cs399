\documentclass{article}

\usepackage{amsmath}
\usepackage{listings}

\lstset{
	language=Lisp,
	numbers=left,
	showstringspaces=false,
}

\bibliographystyle{acm}

\title{CS399 Thesis Draft 1}
\author{Ian Fisher}
\date{25 February 2019}

\begin{document}
\maketitle

\section{Introduction}
This thesis reviews abstract interpretation as a technique for analyzing programs that use faceted execution, a programming language mechanism for enforcing privacy policies. It presents an overview of faceted execution and abstract interpretation, and analyzes in-depth a sample program that uses faceted execution.

\section{Background}
\subsection{Faceted execution\label{sec:facets}}
Faceted execution is a programming-language mechanism that allows sensitive data to be enclosed in special data structures called facets---tuples of the form $\langle l\ ?\ v_H : v_L \rangle$ where $l$ is a label, $v_H$ is the high-confidentiality value, and $v_L$ is the low-confidentiality value. $v_H$ can only be accessed by observers that match the facet's label; other observers can only see $v_L$, which is typically some default value like $0$ or \texttt{null}.

Faceted execution allows privacy policies to be expressed separately from the implementation of the program, meaning that changes to the privacy policy can be made reliably with minimal modification of the application logic. Faceted execution is thus an implementation of policy-agnostic programming \cite{faceted}.

Full support of faceted execution requires changes to core language mechanisms like function application. Concretely, if the function \textit{square-root} were applied to the facet $\langle l \ ?\ 42 : 0 \rangle$, it would return the facet $\langle l \ ?\ \textit{square-root}(42) : \textit{square-root}(0) \rangle$, ensuring that the faceted value remains protected by the privacy policy, even if \textit{square-root} is totally oblivious to the policy.

Researchers have adopted different strategies to implement faceted execution. One strategy is to design a new programming language with faceted-execution primitives built-in. This is the strategy adopted by the Jeeves programming language \cite{jeeves}. Another strategy is to use syntactic macros to graft faceted execution on to an existing language, provided that the language's macro system is rich enough to support it. The \textsc{Racets} programming language adopts the latter strategy, by augmenting the Racket language with syntactic macros \cite{racets}.

The following subsections will present an overview of the specific mechanics of the \textsc{Racets} programming language, but the concepts are general enough to apply to other implementations of faceted execution.

\subsubsection{A simple example of faceted execution}
Policies governing access to data are declared with the \texttt{let-label} form in \textsc{Racets}:

% TODO: Double quotes do not display correctly.
\begin{lstlisting}
(define alice-policy
    (let-label l (lambda (x) (equal? x "Alice")) l))

(define bob-policy
    (let-label l (lambda (x) (equal? x "Bob")) l))
\end{lstlisting}

The two declarations in the source code above create two policies and bind them to the names \texttt{alice-policy} and \texttt{bob-policy}. The policies enforce that only entities identifying themselves as ``Alice'' or ``Bob'', respectively, may view the high-confidentiality value of any facet under the policies.

A faceted data value is created with the \texttt{fac} form:

\begin{lstlisting}
(define my-facet (fac alice-policy 42 0))
\end{lstlisting}

\texttt{my-facet} is defined with Alice's policy, the high-confidentiality value $42$, and the low-confidentiality value $0$.

The \texttt{obs} form is used to view the value of a facet:

\begin{lstlisting}
(obs alice-policy "Alice" my-facet)
\end{lstlisting}

The expression above will evaluate to $42$, as the argument \texttt{"Alice"} satisfies the facet's policy. By contrast, the expression below will evaluate to $0$ since \texttt{"Bob"} does not satisfy the facet's policy.

\begin{lstlisting}
(obs alice-policy "Bob" my-facet)
\end{lstlisting}

The policy passed to a facet must match the policy that the facet was created with. In the case that the facets do not match, \texttt{obs} functions as a no-op (so that the semantics are sound). Each of the two calls to \texttt{obs} below, for instance, will simply return \texttt{my-facet} unchanged.

\begin{lstlisting}
(obs bob-policy "Alice" my-facet)
(obs bob-policy "Bob" my-facet)
\end{lstlisting}

\subsubsection{An example of nested facets}
Faceted values may be nested for more fine-grained control over the views of the data that are available. Alice may define a nested facet as follows:

\begin{lstlisting}
(define location-facet
  (fac alice-policy
    "370 Lancaster Ave, Haverford PA"
    (fac bob-policy
      "Haverford, PA"
      "Pennsylvania")))
\end{lstlisting}

Alice is able to view the full street address of her location. Bob (or anyone else satisfying Bob's policy) may see her town, and anyone else may only see her state.

Alice observes her nested facet in the usual way:

\begin{lstlisting}
(obs alice-policy "Alice" location-facet)
\end{lstlisting}

Bob must make two calls to \texttt{obs} to fully resolve the facet's value:

\begin{lstlisting}
(obs alice-policy "Bob" (obs bob-policy "Bob" location-facet))
\end{lstlisting}

As before, Bob must ensure that the policy he passes to each \texttt{obs} call matches the policy of the facet. In this case, the outer facet uses Alice's policy and the inner facet uses Bob's policy, so the calls to \texttt{obs} must be organized likewise.

\subsubsection{An example of faceted structs}
The behavior of faceted values with Racket structs is consistent but somewhat counterintuitive. Take the following example:

\begin{lstlisting}
(struct emplyoyee (name position salary))
(define bob 
  (employee "Bob" "manager" (fac bob-policy 70000 0)))
\end{lstlisting}

The call to the \texttt{employee} constructor is handled by \textsc{Racets} the way that any function call is: by branching execution on both values on the facet. Therefore, the return value is \texttt{(fac bob-policy (employee "Bob" "manager" 70000) (employee "Bob" "manager" 0))}. Bob's faceted salary can thus be accessed like so:

\begin{lstlisting}
; Equivalent:
(employee-salary (obs bob-policy "Bob" bob))
(obs bob-policy "Bob" (employee-salary bob))
\end{lstlisting}

Somewhat surprisingly, \texttt{obs} is required to observe the name field (and any other field) of the \texttt{employee} object, even though it was not explicitly faceted in the constructor.

\begin{lstlisting}
(employee-name (obs bob-policy "Bob" bob))
\end{lstlisting}

\subsubsection{An example of faceted lists}
Using faceted values with lists involves additional complications. Consider the following example:

\begin{lstlisting}
(define grades (list))
(set! grades (cons (fac alice-policy 84 0) grades))
\end{lstlisting}

As in the example with structs, the programmer likely intended for \texttt{grades} to be of the form \texttt{(list (fac alice-policy 84 0))}, i.e. a regular list containing a single facet. The real value of \texttt{grades} after the \texttt{set!} operation is

\begin{lstlisting}
(fac alice-policy (list 84) (list 0))
\end{lstlisting}

Imagine another grade was added to the list, like so:

\begin{lstlisting}
(set! grades (cons (fac bob-policy 73 0) grades))
\end{lstlisting}

Then the value of the list would be

\begin{lstlisting}
(fac bob-policy
  (fac alice-policy (list 73 84) (list 73 0))
  (fac alice-policy (list 0 84) (list 0 0)))
\end{lstlisting}

encompassing four different possibilities: satisfying both Alice and Bob's policies, satisfying one or the other, or satisfying neither.

The following procedure observes the entire list of grades into a regular Racket list of integers:

\begin{lstlisting}
(define (reveal-grades-rec grade-list policy-list arg)
  (if (empty? policy-list)
      grade-list
      (obs
        (car policy-list)
        arg
        (reveal-grades-rec
          grade-list
          (cdr policy-list)
          arg))))])
\end{lstlisting}

It takes in a list of grades, a list of policies which should correspond index-by-index to the list of grades (remember that \texttt{obs} requires the policy to match the facet's policy), and an argument to pass to the policy predicates.

\subsubsection{Efficiency of faceted execution}
A practical problem of implementing faceted execution is that it can have high runtime cost. As the example with \textit{square-root} above indicates, functions applied to facets must be evaluated twice, once with the high-confidentiality value and once with the low-confidentiality value. The double evaluation imposes a significant runtime cost on faceted execution (as well as complicating the use of functions with side-effects). This cost can be mitigated to some extent by static analysis with an abstract interpreter. If the static analyzer can prove that a facet passed to a function only ever evaluates to its high-confidentiality value, then the evaluation of the function with the low-confidentiality value could be skipped, and significant performance gains could be realized.

\subsection{Abstract interpretation}
One technique for static analysis is abstract interpretation, wherein the computation of a program is modelled with abstract objects (e.g., the abstract ``negative number'' instead of the concrete $-10$) so that real properties of the program can be reasoned about \cite{ai-original}. Abstract interpreters can be derived mechanically from abstract machines, provided that the formalism for the abstract machine is expressed in an amenable manner \cite{aam}. An abstract interpreter of a \textsc{Racets}-like language is under development for this purpose \cite{abstract-inter}.

\subsection{Type theory}
As the example \textsc{Racets} programs presented above indicated, programmers must be careful to apply the correct policies when they observe faceted values. As the \textsc{Racets} language is dynamically typed, errors in the use of faceted execution are not caught until runtime. A static type system for faceted values would be able to more reliably catch programmer errors.

The definition of a type system is ``a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute'' \cite{types}. The program behaviors that a type system are meant to prevent are generally what are called type errors: operations on values for which the operation is not defined.

Naturally, some undesirable program behaviors cannot be detected by a static type system (e.g., looping infinitely is not detectable due to the halting problem), and type systems will sometimes refuse to accept constructs which are in fact safe.

A simple model of a static type system is the typed lambda-calculus. The following exposition is based on chapter 9 of \cite{types}.

The lambda calculus is a simple model of calculation in which the only operation is function application. Syntactically the lambda calculus has three kinds of terms: variables ($x$, $y$, etc.), anonymous functions, also known as abstractions ($\lambda x . x$), and function applications ($t\ t$). The notation $\lambda x . x$ is equivalent to the more traditional notation of $f(x) = x$, except that it has the advantage of not requiring the function to be named. Function application of the form $t_1\ t_2$ is equivalent notationally to $t_1(t_2)$. The body of a lambda function may contain any of the three syntactic forms of the language, so for example $\lambda x . \lambda y . (\lambda z . z)(x)$ is a valid term in the lambda calculus whose outermost abstraction contains another abstraction, which in turn contains an application. For clarity, the application is written with parentheses.

A type system for the lambda calculus (and indeed for any programming language) must assign a type to each syntactic construction in the language.

The typed lambda calculus has the same syntax as the untyped lambda calculus, except that a type annotation is necessary for lambda abstractions, which are now written as $\lambda x: T . x$ instead of $\lambda x. x$, where $T$ is a type.

Type rules are commonly written in the form

\[
\frac{\text{hypotheses}}
{\text{conclusion}}
\]

where \textit{hypotheses} is a set of assumptions and \textit{conclusion} is a type judgment that follows from the hypotheses.

The rule for the types of variables is\footnote{The type rules are taken from Figure 9-1 on p. 103 of \cite{types}.}

\[
\frac{x : T \in \Gamma}
{\Gamma \vdash x : T}
\]

$\Gamma$ stands for an assignment function that maps from a finite number of variable names to their values. The notation $\Gamma \vdash t : T$ expresses the three-place typing relation that syntactic term $t$ has type $T$ given the assignment $\Gamma$. The type rule for variables simply states that if a variable is paired with a certain type $T$ in the assignment function, then $T$ is the variable's type.

The rule for lambda abstraction is a bit more complicated:

\[
\frac{\Gamma, x : T_1 \vdash t_2 : T_2}
{\Gamma \vdash \lambda x : T_1 . t_2 : T_1 \to T_2}
\]

In the hypothesis $\Gamma, x : T_1$ should be read as ``$\Gamma$ augmented with the assignment of type $T_1$ to $x$.'' It is assumed that the variable $x$ is not already in $\Gamma$; if it is, it can simply be renamed. The full hypothesis of the abstraction rule thus states that the body of the lambda function has type $T_2$ with the given assignment function. The conclusion of the abstraction rule states that the lambda function as a whole has the complex type $T_1 \to T_2$.

Finally, the last syntactic form of the language, application, has the type rule

\[
\frac{\Gamma \vdash t_1 : T_{11} \to T_{12}\ \ \ \ \ \ \Gamma \vdash t_2 : T_{11}}
{\Gamma \vdash t_1\ t_2 : T_{12}}
\]

Given that the function has type $T_{11} \to T_{12}$ in $\Gamma$, and the argument has type $T_{11}$, then the expression as a whole has type $T_{12}$.

The three inference rules presented above can be applied to any expression in the typed lambda calculus to detect whether it is well-typed, and if it is, to determine its concrete type. Thus the type system is able to statically eliminate a class of errors from the simple lambda calculus. Type systems for real programming languages are significantly more complex, but involve the same basic formalism of inference rules and type judgments.

\section{Research plan}
My research will proceed in two directions: abstract interpretation and type theory. On the abstract interpretation side of things, it will involve writing several substantial example programs that use faceted execution, for example a grade server in which professors, teacher's assistants, and students all have different levels of access to the grade data, protected by facets. Once I have written these programs in \textsc{Racets}, I will translate them into the language of the abstract interpreter, and assess what conclusions it is able to draw about them, and to what level of precision. For example, if a certain function is sometimes applied to faceted values and sometimes applied to regular values, the abstract interpreter may or may not be able to identify the call sites that require special handling of the faceted execution, and those that can be run normally. In general, the more fine-grained the conclusions the abstract interpreter can draw, the greater the improvement of performance time.

The other part of my research will consist in writing a formal type system for the \textsc{Racets} programming language. As noted in section \ref{sec:facets}, correct use of faceted execution requires that the programmer take care to always match a faceted value with its corresponding policy in calls to \texttt{obs}. A type system that could determine whether a policy corresponds with a facet or not would be able to statically prove whether any call to \texttt{obs} results in a grounded (i.e., non-faceted) value or not---a useful result for checking the correctness of the program.

My research will aid in understanding the efficacy of static analysis and type theory as applied to faceted execution, and thus contribute to improving the programming-language resources that software developers have available to correctly and reliably enforce privacy policies.

\bibliography{thesis}

\end{document}
